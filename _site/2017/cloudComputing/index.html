<!DOCTYPE html>
<html lang="en-us">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script type="text/javascript">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath:[ ['$$','$$'], ['\\[','\\]'] ], 
        processEscapes: true
    }        
})
</script>

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      SocialCloudComputing &middot; Note
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/css/custom.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">


</head>


  <body class="theme-base-0b">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href=/>
          Note
        </a>
      </h1>
      <p class="lead"></p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href=/>Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/Archive/">Archives</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      

	
	<li>
		<a href="https://github.com/moved0311">
		   <span class="fa-stack fa-lg">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-github fa-stack-1x icon"></i>
          </span>
		</a>
	</li>
	

	
	  <li>
		<a href="https://www.facebook.com/100000329876068">
		  <span class="fa-stack fa-lg">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-facebook fa-stack-1x icon"></i>
          </span>
		</a>
	  </li>
	

    </nav>

    <p>@ 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">SocialCloudComputing</h1>
  <span class="post-date">25 Feb 2017</span>
  <h3 id="outline">Outline</h3>
<ul>
  <li>Social Network</li>
  <li>Centrality Analysis</li>
  <li>Community Detection</li>
  <li><a href="#3">Link Prediction</a></li>
  <li><a href="#4">Label Prediction</a></li>
  <li><a href="#5">Information Diffusion</a></li>
  <li>Role/Postion Analysis</li>
  <li>Social Relation Extraction</li>
  <li><a href="#9">Cloud Computing</a></li>
</ul>

<!--more-->

<h4 id="journals">Journals</h4>
<ul>
  <li>Nature</li>
  <li>Science</li>
  <li>Physical Review</li>
  <li>Social Networks</li>
  <li>ACM Transactions on Knowledge Discovery from Data (TKDD)</li>
  <li>ACM Transactions on Intelligent Systems and Technology(TIST)</li>
  <li>ACM Transactions on Social Computing(TSC)</li>
  <li>IEEE Transactions on Knowledge and Data Engineering(TKDE)</li>
  <li>IEEE Transactions on Computational Social System</li>
</ul>

<h1 id="social-networks">Social Networks</h1>

<table>
  <tbody>
    <tr>
      <td>Sociocentric</td>
      <td>Egocentric</td>
    </tr>
    <tr>
      <td>根據整群分析</td>
      <td>根據個人分析,向外延伸</td>
    </tr>
  </tbody>
</table>

<p><strong>Newman</strong> 將Network分為四類:</p>
<ul>
  <li>information Network<br />
paper reference network <br />
web hyperlink network <br />
Language network</li>
  <li>Social Network<br />
FB好友關係</li>
  <li>Technology Network<br />
電力系統(Power grid)</li>
  <li>Biologycal Network<br />
蛋白質互動關係,食物鏈</li>
</ul>

<p>為什麼要分這麼多類Network?</p>
<blockquote>
  <p>因為要分析的重點不同,可能在information Network中很重要的,卻在Social Network可能不是那麼重要</p>
</blockquote>

<h4 id="network-properties">Network Properties</h4>
<ol>
  <li>
    <p>small-world effect 六度分離理論[1967 Milgram]  <br />
平均透過6層關係可以連到任何你不認識的人</p>

    <p>補充資料：</p>
    <blockquote>
      <p><a href="https://zh.wikipedia.org/wiki/%E7%B1%B3%E7%88%BE%E6%A0%BC%E5%80%AB%E5%AF%A6%E9%A9%97">米爾格倫實驗 Milgram experiment 服從威權實驗</a></p>
    </blockquote>
  </li>
  <li>Transitivity<br />
 朋友的朋友很可能也是你朋友<br />
 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E8%81%9A%E7%B3%BB%E6%95%B0">Clustering Coefficient</a><br />
 $ \frac{三角形數量}{任三點連線數} $</li>
  <li>Degree distribution<br />
 Real world network : <br />
 Power law
    <blockquote>
      <p>P<sub>k</sub> = CK<sup>-α</sup></p>
    </blockquote>

    <p>Heavy-tailed degree distribution<br />
 大量很低的數量,集合起來還是很驚人</p>
  </li>
  <li>Network resilience<br />
 如果拿掉一些點/邊,連通性會有什麼變化？<br />
 (e.g.有些人掛了,離職)<br />
 連接path的長度變長,或是disconnect <br />
 廣告投放要投在哪個點影響力最大,如果是傳染病隔離哪個點最有效?</li>
  <li>Mixing patterns<br />
 探討兩邊節點的type,可能因為什麼關係成為朋友(職業/興趣/文化)</li>
  <li>Degree Correlations<br />
 觀察兩個degree高或兩個degree低的點之間的關聯性</li>
  <li>Community Structure <br />
 一個點和邊的密度很高的區域,稱作一個community</li>
  <li>Network motifs    <br />
在音樂上motifs是一種作曲法,靈感的意思<br />
 在生物基因上是一些重複的pattern<br />
 在社群希望找到出現次數較高的motifs(最常出現的subgraph)</li>
</ol>

<p>補充資料 : <a href="https://en.wikipedia.org/wiki/Erd%C5%91s_number">Erdős Number</a>
<br /></p>
<h1 id="centrality-analysis">Centrality Analysis</h1>

<ul>
  <li>
    <p>Centrality Measure 找到最重要的點(central)</p>

    <p>local</p>
    <blockquote>
      <ol>
        <li>Degree</li>
      </ol>
    </blockquote>

    <p>global</p>
    <blockquote>
      <ol>
        <li>Closeness</li>
        <li>Betweeness</li>
        <li>Eigenvector</li>
      </ol>
    </blockquote>
  </li>
  <li>
    <p>Group Centrality<br />
找到一群最有影響力的人<br />
在小世界理論中,如果送信到目標的前一步,都是經由特定的三個人,代表這三個人很重要</p>
  </li>
</ul>

<p><strong>Social actors(群眾的智慧)</strong></p>
<ol>
  <li>Connectors<br />
認識很多人,很擅長社交</li>
  <li>Mavens<br />
資訊專家,知道很多各式訊息</li>
  <li>Salesman<br />
容易說服別人,擅長協調</li>
</ol>

<p><strong>Social network的四種centrality</strong></p>

<p><strong>local</strong></p>

<ol>
  <li>
    <p>Degree centrality<br />
若點的degree很高可能代表這個點很重要
<img src="/img/cloudcomputing/degreeCentrality01.png" alt="degreeCentrality" />
但degree centrality的缺點是如果有一個點的degree很低,
但是這個點連接了多個community,
用degree centrality看不出這個點很重要</p>

    <p><img src="/img/cloudcomputing/degreeCentrality02.png" alt="degreeCentrality" /></p>
  </li>
</ol>

<p><strong>global</strong></p>

<ol>
  <li>Betweeness Centrality<br />
 所有點A到點B的shortest path有幾條經過<script type="math/tex">Node_i</script></li>
  <li>Closeness Centrality  <br />
 點i和所有點j的shortest path平均的距離</li>
  <li>Eigenvector Centrality    <br />
 這個點的重要性,透過看他朋友點的重要性<br />
eigenvector
    <blockquote>
      <p>一個向量乘上一個矩陣(transform),方向不變但scale可能會變<br />
Ax = <script type="math/tex">\lambda</script>x<br />
A矩陣代表social network關係(1:朋友關係,0:不是朋友)<br />
x代表重要性</p>
    </blockquote>
  </li>
</ol>

<p><strong>最短路徑演算法</strong><br />
unweighted graph</p>
<ol>
  <li>BFS</li>
  <li>Floyd-Warshall</li>
</ol>

<p><strong>Group centrality</strong></p>
<blockquote>
  <p>找出social network中幾個最有影響力的人<br />
或指定某幾個人觀察這些人的影響力</p>
</blockquote>

<hr />

<!-- 20170413  -->
<h1 id="comunity-detection">Comunity Detection</h1>

<p><strong>Properties of cohesion 凝聚力的判斷</strong></p>
<ol>
  <li>Mutuality of ties<br />
 所有subgroup彼此都有邊相連,在graph中就是完全圖的概念<br />
 e.g. clique</li>
  <li>Closeness or reachability of subgroup members<br />
 不需要直接有邊相連,間接有相連就行了<br />
 e.g. N-clique,N-clan,N-club</li>
  <li>Frquency of ties among members<br />
 Mutuality of ties是說假設有n個人必須要和n-1個人相連,<br />
 那Frquency of ties among members只需要和n-k個人相連就可以了<br />
 是Mutuality of ties放寬版本<br />
 e.g. K-plex,K-core</li>
  <li>Relative frequency of ties among subgroup members compared to non-member</li>
</ol>

<p><strong>Clique</strong></p>
<blockquote>
  <p>maximal complete subgraph,最大的子圖任兩點都有邊相連</p>
</blockquote>

<p><img src="/img/cloudcomputing/community01.png" alt="clique img" /></p>

<ul>
  <li>N-clique <br />
  在grahp中,任兩個點之間的距離&lt;N  <br />
  e.g. 2-cliques: {1,2,3,4,5},{2,3,4,5,6}</li>
  <li>N-clan<br />
  必須是N-clique<br />
  在subgraph中,任兩個點之間的距離&lt;N<br />
  e.g. 2-clan: {2,3,4,5,6} <br />
  (4-&gt;5要經過6,但只考慮1,2,3,4,5這個subgraph)</li>
  <li>N-club<br />
  不必是N-clique,但一定要是subgraph of n-cliques  <br />
  2-clubs: {1,2,3,4},{1,2,3,5},{2,3,4,5,6}</li>
  <li>K-plex<br />
  如果是clique每個點的degree是n-1<br />
  如果是k-plex,每個點的degree是n-k<br />
  假設subgraph有4個點,2-plex每個點的degree至少是2</li>
  <li>K-core<br />
  至少和k個人是朋友
  每個點的degree至少是k</li>
</ul>

<p><strong>Community Detection Approaches</strong></p>
<ul>
  <li>Partitioning
    <ul>
      <li><a href="#KL"> Kernighan-Lin Alog(KL algorithm)</a></li>
    </ul>
  </li>
  <li>Hierarchical
    <ul>
      <li><a href="#HC"> Hierarchical Clustering</a></li>
    </ul>
  </li>
  <li>Edge-Removal
    <ul>
      <li><a href="#MM"> Modularity Maximization</a></li>
      <li><a href="#BC"> Bridge-Cut Algo</a></li>
    </ul>
  </li>
</ul>

<h2 id="KL"> KL algorithm </h2>
<div class="highlighter-rouge"><pre class="highlight"><code>Input  : weighted graph  
Output : 切成兩個equal-size subgraph,且橫跨兩群的crossing edge的總和最小     
</code></pre>
</div>

<p><strong>名詞定義</strong></p>
<ul>
  <li>external cost<br />
  在A群中的點連到B群中的點(crossing edge)的cost</li>
  <li>internal cost<br />
  在A群中的點連到在A群中的其他點的cost</li>
  <li>difference<br />
  external cost - internal cost</li>
  <li>
    <p>Gain<br />
  用來評估是否要交換的值,大於0代表兩點做交換後crossing edge的總和降低 <br />
  例如a,b屬於不同群,ab做交換<br />
  Gain = <script type="math/tex">D_a + D_b - 2\times W_{ab}</script><br />
  (Difference a + Difference b - 2 * weighted <script type="math/tex">\overline{ab}</script>)</p>

    <p>Gain公式推導：<br />
  若考慮a,b交換<br />
  old cost = <script type="math/tex">z + E_a + E_b - W_{ab}</script> <br />
  new cost = <script type="math/tex">z + I_a + I_b + W_{ab}</script><br />
  old cost - new cost (Gain) = <script type="math/tex">(E_a - I_a) + (E_b - I_b) - 2W_{ab} = D_a + D_b - 2\times W_{ab}</script></p>
    <blockquote>
      <p>z (與a,b沒有連接的其他crossing edge總和)<br />
  E (external cost)<br />
  I (internal cost)</p>
    </blockquote>
  </li>
</ul>

<p><strong>步驟</strong></p>
<ol>
  <li>任意切成兩半</li>
  <li>計算每一點的difference</li>
  <li>計算每個邊的gain</li>
  <li>從gain最大的開始做交換,交換後的點不再考慮(lock)</li>
  <li>交換到直到全部的點都被lock住</li>
  <li>挑gain總和最大的就是最終交換結果</li>
</ol>

<p>交換數回合,若遇到gain是負的紀錄下來並繼續嘗試做交換,到最後再找gain最好的
交換完後的點就lock住不進入下一回合</p>

<p><strong>KL algorithm複雜度</strong><br />
<script type="math/tex">O(n^2)</script> 找到最適合交換的兩點,有n pair要交換 ⇒ <script type="math/tex">O(n^3)</script> 
<!-- 20170413  --></p>

<!-- 20170512,20170621-->
<h2 id="HC">Hiraichiecal Clustering</h2>
<p>bottom-up<br />
每一回合都找兩個最像的做合併</p>
<ul>
  <li>single link  <br />
  距離取min</li>
  <li>complete link<br />
  距離取max</li>
</ul>

<h4 id="distance-matrix">Distance Matrix</h4>
<ol>
  <li>Approach1  <br />
計算weights W<script type="math/tex">_{ij}</script>
    <ul>
      <li>i到j的路徑越多代表i和j關係越好</li>
      <li>只能找non-overlapped paths</li>
      <li>只要i到j的路徑都算(weighted by length)</li>
    </ul>

    <p>X<script type="math/tex">_{ij}</script> = <script type="math/tex">\frac{1}{W_{ij}}</script></p>
  </li>
  <li>Approach 2<br />
 如果i和j視同一群,那他們有相似的behavior<br />
 behavoir<br />
     i和j到commuinty其他點的平均距離相似</li>
  <li>Approach 3<br />
 <script type="math/tex">\frac{J(i,j)}{min(K_i,K_j)}</script> <br />
 看兩個人共同朋友個數,共同朋友越多J(i,j)越大</li>
</ol>

<h2 id="edge-removal-approach">Edge-removal Approach</h2>
<blockquote>
  <p>不斷的拿掉邊(bridge edge),會出現越多的群數,直到符合要的群數</p>
</blockquote>

<h3 id="gn-algorithm">GN algorithm</h3>

<blockquote>
  <p>起始是一個commuinity,每一回合拿掉betweeness最高的邊,並重新計算每個邊的betweeness,並持續到出現想要分到的群數<br />
這裡的betweeness是以邊考量,不是用點。考慮任兩點的最短距離有幾條會通過$edge_i$</p>
</blockquote>

<p><strong>不同方法計算邊的betweeness</strong></p>
<ol>
  <li>shortest path<br />
 任兩點最短路徑有多少條會經過邊</li>
  <li>Random-walk 
 計算a會走到b的機率<br />
 a走到b會經過邊v的機率</li>
  <li>Current-flow
 引進電路學概念的計算方法</li>
</ol>

<p>缺點</p>
<ol>
  <li>計算最短路徑耗時
 O($m^2n$)
    <div class="highlighter-rouge"><pre class="highlight"><code> m   edge 
 mn  betweeness  
</code></pre>
    </div>
  </li>
  <li>什麼時候停? <br />
 什麼時候是最佳的分割</li>
</ol>

<h2 id="modularity">Modularity</h2>
<p>Modularity measure:</p>
<blockquote>
  <p>how good a particular partition forms a community.<br />
評估community切分的好不好</p>
</blockquote>

<p>$ Q = \frac{1}{2m}\sum_{ij}{(A_{ij}-\frac{k_ik_j}{2m})\delta_{ij}}$</p>

<blockquote>
  <p>m : # of edges<br />
$A_{ij} = 1$ 如果i,j點之間有邊,沒有邊$A_{ij}= 0$ <br />
$k_i$ : degree of $node_i$<br />
$\delta_{ij} = 1 如果i,j屬於同一個community,否則為0$<br />
Q : 分群的分數</p>
</blockquote>

<p>Q = 0 no community<br />
Q ~ 1 prefect cut</p>

<h4 id="newman-fast-alogorithm">Newman Fast Alogorithm</h4>
<p>利用hireachcal合併,並每個步驟算modurity,並找出最高的Q做切分</p>

<h2 id="BC"> Bridge cut </h2>

<p><strong>Clustering coeffiecient</strong></p>
<blockquote>
  <p>觀察v的鄰居的朋友關係,例如v有4個朋友,那4個人最多有6個關係,算關係的比例,實際上有關係/最多有幾個關係</p>
</blockquote>

<p>$ C_v = \frac{2|\cup_{i,j \in N(v)}e(i,j)|}{d(v)(d(v)-1)} $</p>
<blockquote>
  <p>N(v) : 和v直接相連的點<br />
d(v) : 點v的degree<br />
e(i,j) = 1 如果ij有邊相連,否則=0</p>
</blockquote>

<p><strong>Bridge Centrality</strong><br />
	rank of betweenness centrality * rank of bridging coeffiecient<br />
	如果只考慮betweeness(global)會有一些情況不太好  <br />
	加入bridge centrality可以考慮到local的特質</p>

<p><strong>Community Search</strong><br />
    給一個social network,並給一些query(其中幾個人),<br />
    given grahp G, a set of query node<br />
    goal: find a densely subgraph of G, and contains the query nodes</p>

<p><strong>Induced Subgraph</strong><br />
xy edge在G中,xy edge也要在induce subgraph中</p>

<p><strong>goodness function</strong></p>
<ol>
  <li>edge degree
 時間複雜度太大</li>
  <li>average degree</li>
  <li>minumin degree
 這群人認識最少的人,讓這個人的值變大
 induced subgraph的degree<br />
 容易受到outlier影響</li>
</ol>

<p><strong>Constrain</strong>  <br />
distance constrain<br />
限制邀請來的人的最長距離</p>

<p><strong>Monotone Function</strong></p>
<ul>
  <li>monotone increaing</li>
  <li>monotone decresing</li>
  <li>non-monotone
<!-- 20170512,20170621--></li>
</ul>
<hr />

<!-- 20170421,20170621 -->
<h1 id="3">Link Prediction </h1>
<blockquote>
  <ul>
    <li><a href="#LP">Link Prediction</a></li>
    <li><a href="#NSBM">Node-wise Similarity Based Methods</a></li>
    <li><a href="#TPBM">Topological Pattern Based Methods</a></li>
    <li><a href="#PMBM">Probabilistic Model Based Methods</a></li>
  </ul>
</blockquote>

<h2 id="LP"> Link Prediction </h2>
<p><strong>Goal</strong></p>
<ol>
  <li>Predict the existence of links</li>
  <li>Predict the type of links</li>
</ol>

<p><strong>Strategies of Prediction</strong></p>
<ol>
  <li>Knowledge-driven strategy<br />
 專家系統(領域專家提供rule)</li>
  <li>Data-driven approach</li>
</ol>

<p><strong>Link Prediction Problems</strong></p>
<ol>
  <li>Link existence prediction<br />
 邊是否存在或是隨著時間變化,邊會有什麼變化</li>
  <li>Link classification<br />
 關係的總類</li>
  <li>Link regression<br />
 最重要的邊是哪一個</li>
</ol>

<p><strong>Application</strong></p>
<ol>
  <li>Web hyperlink creation</li>
  <li>Collaborative filitering</li>
  <li>Information retrieval</li>
  <li>Clustering</li>
  <li>Record linkage</li>
</ol>

<h2 id="NSBM"> Node-wise Similarity Based Method</h2>
<blockquote>
  <p>計算兩個點的相似度,如果兩個點很相似他們可能就有link<br />
e.g. Similarity between words<br />
觀察word的前後文字來判斷相似程度</p>
</blockquote>

<p><strong>Learning-Based Similarity Measure</strong></p>
<ul>
  <li>Binary Classification Approach
    <ul>
      <li>Decision Tree</li>
    </ul>
  </li>
  <li>Regression-based Approach(迴歸)  <br />
  e.g linear regression<br />
  <script type="math/tex">Y = \alpha + \beta_1X_1 + \beta_2X_2 + ... + \beta_nX_n</script><br />
  利用學習方式估計出<script type="math/tex">\alpha , \beta</script></li>
</ul>

<h2 id="TPBM"> Topological Pattern Based Methods </h2>
<blockquote>
  <p>計算兩點之間的分數,若大於某個值就表示他們之間有關係(連線)</p>
</blockquote>

<ul>
  <li><strong>Local Method</strong>
    <ul>
      <li>Common Neighbors(CN)  <br />
  計算$node_x$和$node_y$的共同鄰居</li>
      <li>Salton Index<br />
  類似cosine similiary</li>
      <li>Jaccard Coefficient(JC)
        <blockquote>
          <p>交集/聯集</p>
        </blockquote>

        <p>$\frac{node_x和node_y的共同鄰居}{node_x的鄰居和node_y的鄰居做聯集}$</p>
      </li>
      <li>Leicht-Holme-Newman Index(LHN)</li>
      <li>Hub Promoted Index(HPI)<br />
  Hub概念像是入口網站,類似目錄連到很多子分支</li>
      <li>Hub Depres Index(HDI)</li>
      <li>Adamic/Adar(AA) <br />
  看共同鄰居的鄰居數量取log和倒數加總
  $Score(x,y) = \sum_{z \in N(x) \cap N(y)} \frac{1}{log|N(z)|}$</li>
      <li>Resource Allocation Index(RA)<br />
  和AA差在分母沒有取log</li>
      <li>Preferential Attachment<br />
  $node_x的鄰居\times node_y$鄰居</li>
    </ul>
  </li>
  <li><strong>global Method</strong>
    <ul>
      <li>katz<br />
  計算所有$node_x到node_y$距離是1,2,3..n的path有幾條,乘上一個參數$\beta$做加總</li>
      <li>Hitting Time<br />
  x走到y,做random work的期望值作為比較條件</li>
      <li>PageRank</li>
      <li>SimRank</li>
    </ul>
  </li>
</ul>

<h2 id="PMBM"> Probabilistic Model Based Methods </h2>
<p>relational Markov model<br />
<!-- 20170421,20170621 --></p>

<hr />

<!-- 20170621 -->
<h1 id="4">Labeld Social Network </h1>
<h4 id="type-of-labels">Type of Labels</h4>
<ol>
  <li>Binary</li>
  <li>Numeric</li>
  <li>Categorical</li>
  <li>Free-text</li>
</ol>

<h4 id="goal">Goal</h4>
<p>給一個network且只有部份點有labeled,用已知的label來預測未知的label</p>
<ol>
  <li>Predict the type of nodes</li>
  <li>Predict the attribute values of nodes</li>
</ol>

<h4 id="label-prediction">Label Prediction</h4>
<blockquote>
  <p>根據已知的label預測未知點的label</p>
</blockquote>

<h4 id="different-setup-for-label-prediction">Different setup for label prediction</h4>
<ol>
  <li>Inference vs. Learning<br />
 Inference(unsupervised)<br />
 Learning(supervised)</li>
  <li>Disjoint vs. Collective<br />
 Disjoint : 沒有標籤的點就不考慮<br />
 Collective : 沒有標籤的點也會放進去考慮</li>
  <li>Across-network vs. within-network learning<br />
 Across-network拿一個social network model去預測另一個social network<br />
 within-network拿全部資料做的model來做預測</li>
</ol>

<h4 id="node-label-prediction">Node Label Prediction</h4>
<ul>
  <li><a href="#RNC">Relational Neighbor Classifier</a></li>
  <li><a href="#GE">Ghost Edge</a></li>
  <li><a href="#RMN">Relational Markov Network</a></li>
  <li><a href="#PEM">Pseudolikelihood EM </a></li>
</ul>

<h2 id="RNC"> Relational Neighbor Classifier </h2>
<blockquote>
  <p>看鄰居多數是什麼就判斷node是什麼</p>
</blockquote>

<ul>
  <li>問題：<br />
  如果已知的點很少,unknown的很多(Sparse label),若只用一個點判斷另一個點就沒那麼可靠</li>
  <li>解決：
  Iterative Relation Neighbor classifier  <br />
  判斷分為好幾回合,若多數點是unknown那就判斷是unknown <br />
  unknown也視為一種label<br />
<!-- 20170621 --></li>
</ul>

<!-- =====================  20170622 ================================= -->

<h2 id="GE">Ghost Edges for Node Label Prediction</h2>
<p>將沒有label的node用Ghost edge連到有label的node,有label的node就算沒有實體的edge連到unlabel node但是也可以造成影響。且影響力可以依據距離來做調整。</p>

<h4 id="steady-state-probability">Steady-state Probability</h4>
<ul>
  <li>Markov Process  <br />
  e.g. 城市和郊區遷移問題</li>
</ul>

<h4 id="random-walk-with-restart">Random walk with Restart</h4>
<p>概念有點類似Markov Process,使用Adjacency matrix A表示network,有一個初始的起點$\vec{V_q}$,並且有一個Restart的機率c每一回合有機率回到起點。利用random walk在圖上移動到穩定,並利用來判斷每個點對某一點的影響力,在對這些影響力做等級劃分,依照機率分為ABCDEF…等級</p>

<p>Steady-state vector : $ \vec{U_q} = (1-c)A \vec{U_q}+c \vec{V_q}$<br />
Initial state : $\vec{U_q} = \vec{V_q}$</p>

<p><strong>Two Classifers</strong></p>
<ol>
  <li>GhostEdgeNL</li>
  <li>GhostEdgeL<br />
 Logistic regression</li>
</ol>

<hr />

<h1 id="5">Information Diffusion</h1>
<blockquote>
  <p>想知道消息/能量/疾病/..的擴散方向,透過什麼方式擴散,可以擴散到哪等等問題</p>
</blockquote>

<p><strong>three elements of diffusion process</strong></p>
<ol>
  <li>Senders 散佈者</li>
  <li>Receivers 接收者</li>
  <li>Medium(channel) 中間人</li>
</ol>

<p><strong>Types of Information Diffusion</strong></p>
<ul>
  <li>Herd behavior(global information)<br />
  群眾行為,大多數人怎麼做,就有可能會跟著做</li>
  <li>Information cascades(local information)<br />
  FB朋友互相的轉發貼文</li>
  <li>Diffusion of innovation<br />
  沒有明確的網路圖形,透過電視廣告,從朋友聽說等等的傳遞方式</li>
  <li>Eqidemics
  疫情擴散</li>
</ul>

<p><img src="/img/cloudcomputing/InformationDiffusion.png" alt="Information Diffusion" /></p>

<h2 id="herd-從眾">Herd 從眾</h2>
<blockquote>
  <p>有一群人做決策,大家會趨向一個方向</p>
</blockquote>

<p><strong>Herd example</strong></p>
<ol>
  <li>
    <p>Soloman Asch Experiment<br />
 左邊一個長條圖形和右邊有三個不同長短的長條圖形,比較長度和哪個最相近</p>
  </li>
  <li>
    <p>Urn Experiment (Bayesian Modeling of Herd Behavior)<br />
 有多個學生來猜測甕裡面主要是放什麼顏色的珠寶<br />
 甕裡面珠寶有紅色和藍色,不會是全部是藍色或全部是紅色<br />
 每個學生從甕中抓一把,根據自己手中的內容和黑板上紀錄結果做預測<br />
 並將預測結果寫在黑板上,後面的同學可以參考 <br />
 那可能抽到大多數是藍色,但黑板上紀錄大多是紅色,可能會影響你的猜測</p>
  </li>
</ol>

<h2 id="information-cascade">Information Cascade</h2>

<p><strong>Diffusion Models</strong></p>
<ol>
  <li>Descriptive models<br />
 機率模型</li>
  <li>Operational models<br />
 一步一步的動態模擬擴散<br />
 每個點可以是Active或Inactive<br />
 假設:<br />
 每個node可以從inactive轉成active但不能從active轉成inactive<br />
 e.g.
    <ul>
      <li>Linear Threshold Model</li>
      <li>Independent Cascade Model</li>
    </ul>

    <p><strong>Linear Threshold Model</strong>  <br />
 每個人都會有一個threshold代表會變成active門檻值  <br />
 每個邊上會有影響力的值(可以是單向或雙向)  <br />
 如果你的鄰居加總的影響力大於你本身的threshold那你也會變成active  <br />
 由Senders開始一步一步的擴散</p>

    <p><strong>Independent Cascade Model</strong><br />
 每一個人只能影響鄰居一次,失敗了不能再影響一次<br />
 邊上權重是影響成功的機率</p>
  </li>
</ol>

<h2 id="influence-maximization-problem">Influence Maximization Problem</h2>
<p>給一些起始的senders觀察最後有哪些人被影響<br />
給k個senders並且找出這k個senders是誰且最後影響的人數最多<br />
(應用: 廣告要放在哪裡)<br />
Constrained optimization problem</p>

<p>問題難度: NP-hard <br />
證明這個問題的難度:<br />
    符合Submodular Function,且要在所有node中找出k個,使得f(k)為maximized<br />
    已經被證明為NP-hard問題</p>

<p><strong>Submodular Function</strong></p>
<ul>
  <li>Non-negative</li>
  <li>Monotone</li>
  <li>Submodular 邊際效應遞減
    <blockquote>
      <p>f(a,b,v) - f(a,b) &gt; f(a,b,c,v) - f(a,b,c)<br />
  原來有a,b加入v所增加的量大於原來有a,b,c加入v所增加的量<br />
  例如原本能考60分,讀一天可以考到80分,<br />
  和原來能考90分,可是讀一天只能考到95分</p>
    </blockquote>
  </li>
</ul>

<p>遇到NP-hard問題考慮的解法</p>
<ul>
  <li>Approximation Approach</li>
  <li>平行運算</li>
</ul>

<p><strong>Approximation Approach</strong><br />
Greedy algorithm<br />
每回合找出Submodular最大的作為sender</p>

<h2 id="outbreak-detection">Outbreak Detection</h2>
<blockquote>
  <p>能不能透過放sensor提早知道消息的擴散</p>
</blockquote>

<p>給一個network G(V,E),找到placement A(sensor)<br />
goal : to max R(A)<br />
R(A) : reward  <br />
c(A) : cost</p>

<p><strong>placement objective</strong></p>
<ul>
  <li>detection likelihood  <br />
  希望所有事件都偵測到</li>
  <li>detection time  <br />
  多久偵測到</li>
  <li>Population affected<br />
  已經擴散多少,多少人知道</li>
</ul>

<p><strong>Approached of Outbreak Detection</strong></p>
<ol>
  <li>Heuristic in simple case
 each node has equal cost<br />
 每次都加入一個sensor,那計算每一個node加入的邊際效應<br />
 並選最大的邊際效應加入</li>
  <li>Heuristic in more complex case<br />
多考慮cost,所以算法變成每次加入最大的benifit/cost</li>
</ol>

<h2 id="team-formation-in-social-networks">Team Formation in Social Networks</h2>
<blockquote>
  <p>如何要找到正確的人,組成一個團隊</p>
</blockquote>

<ul>
  <li>Task</li>
  <li>Expert</li>
  <li>Network</li>
  <li>Effective</li>
</ul>

<p>Given</p>
<blockquote>
  <p>set of n individuals , a graph , a task</p>
</blockquote>

<p>Find</p>
<blockquote>
  <p>必須包含task,individuals skill聯集要包含task<br />
    communication cost要最小越好</p>
</blockquote>

<p><strong>Communication Cost</strong><br />
Diameter</p>
<ul>
  <li>distance     : shortest path (geodesic distance)</li>
  <li>eccentricity : 其中一個點到其他所有點的shortest path,並取最大的值</li>
  <li>radius       : minimun eccentrictity 溝通成本最低</li>
  <li>diameter     : maximun eccentrictity 溝通成本最高</li>
</ul>

<p>measure communication cost</p>
<ol>
  <li>diameter</li>
  <li>minimum spanning tree</li>
</ol>

<p>不管用diameter或是MST都是NP-hard<br />
那縮小範圍可以考慮到加入限制 : <br />
<script type="math/tex">\quad</script>人數越少越好 → set cover problem(NP-complete)</p>

<p>作者提出的方法將set cover problem視為baseline作為比較<br />
NPC問題通常找近似解,所以需要一個比較的方法</p>
<ol>
  <li>RarestFirst Algo for Diameter-TF<br />
 先從skill少的加入集合考慮,必找diameter低的持續加入集合<br />
 假設skill少的同時有2個人會,那要挑誰？
    <ol>
      <li>隨便挑</li>
      <li>從欠缺能力看,計算和有欠缺技能的node計算diameter,挑minimun diameter</li>
    </ol>
  </li>
  <li>
    <p>The Enhanced Steiner ALog. for MST-TF<br />
 The Minimum Stener Tree Problem (NP-hard)<br />
     給入require的點,必找出含有這些點的tree<br />
     如果require是所有的點,問題就會變成minimal spanning tree,<br />
     minimal spanning tree是minimum stener tree的speical case<br />
     如果require只有兩個點,那就會變成shortest path的問題</p>

    <p>將每一個skill,各至成為一個node,且連到擁有這些技能的點,<br />
 將題目轉為stener alog,require就是自己建立的node,找到後再去除這些node<br />
 1.從自己建立的node找一個點放到set中<br />
 2.計算和require和set中的距離,取最短,並將path上的點加入set,直到所有require都在set中 <br />
<!-- 20170512 --></p>
  </li>
</ol>

<!-- class -->
<p>Epidemics
疫情會有一個週期
接觸後有多少機率會傳染p</p>

<p>一個人有傳染並，那他會傳染給多少的人</p>

<p>Basic reproductive number $R_0$</p>

<p>$R_0 &lt; 1$ 疫情會在一段時間內消失
$R_0 &gt; 1$ 疫情會持續下去</p>

<p>目標將低k或是p</p>

<p>Epidemics modeling</p>
<ul>
  <li>Statistics models</li>
  <li>Agent-based models</li>
  <li>network models</li>
</ul>

<p>Statistics model
SIR model</p>
<ul>
  <li>Susceptible</li>
  <li>Infectious
  被感染</li>
  <li>Removed
  病情痊癒</li>
</ul>

<p>參數</p>
<ol>
  <li>p 病情的傳染機率</li>
  <li>$t_i$ 病情的持續時間</li>
</ol>

<!-- class -->

<!-- 20170525 -->
<h1 id="9">Cloud computing</h1>
<ul>
  <li><a href="#9_1">MapReduce</a></li>
  <li><a href="#9_2">Pig Programming</a></li>
</ul>

<p><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-145.pdf">The NIST Definition of Cloud Computing</a></p>

<ul>
  <li>Parallel</li>
  <li>Distribute</li>
  <li>Grid</li>
  <li>Utility Computing</li>
</ul>

<h4 id="parallel-computing">Parallel Computing</h4>
<blockquote>
  <p>將大問題拆成小問題且同時執行</p>
</blockquote>

<h4 id="distributed-computing">Distributed Computing</h4>
<blockquote>
  <p>多台獨立電腦透過網路連結且為同一個任務工作</p>
</blockquote>

<h4 id="grid-computing">Grid Computing</h4>
<blockquote>
  <p>是一種Distributed Computing</p>
</blockquote>

<h4 id="utility-computing">Utility Computing</h4>
<blockquote>
  <p>讓計算像使用電力,水等資源,只要有一個client端就可以使用,不在本地端計算,而是在提供服務的地方計算</p>
</blockquote>

<h4 id="performance-optimization">Performance Optimization</h4>
<ul>
  <li>Parallel Computing</li>
  <li>Job Scheduling</li>
  <li>Load Balancing</li>
</ul>

<h4 id="survice-models">Survice Models</h4>
<ol>
  <li>IaaS(Infrastructure as a Service)
    <blockquote>
      <p>包含硬體,OS,driver,networking<br />
使用者不用管理或控制底層的東西</p>
    </blockquote>

    <p>Virtualization:<br />
 Abstraction of logical resource away from underlying phyical resources<br />
 Improve utilization,security</p>
  </li>
  <li>Paas(Platform as a Service)
    <blockquote>
      <p>提供工程師一個寫程式的環境,包含程式語言和工具,且不用管理底層的硬體但可以做控制</p>
    </blockquote>

    <p>e.g. Programming IDE,Programming API,System Control interface,Hadoop,Google App Engine,Microsoft Windows Azure</p>
  </li>
  <li>SaaS(Software as a Service)
    <blockquote>
      <p>提供應用程式給一般人使用,透過clinet界面就可以使用</p>
    </blockquote>

    <p>e.g. web Service,Google App</p>
  </li>
</ol>

<!-- 20170525 -->

<!-- class -->
<h1 id="9_1">MapReduce</h1>

<ul>
  <li>A programming model</li>
</ul>

<p>local aggregation
map跑完的結果先處理(先加起來)
可以提升效能,在sort and shuffle可以減少計算</p>

<p>3 approahes</p>
<ul>
  <li>Combiner</li>
  <li>Improved Word Count
<!-- class --></li>
</ul>

<!-- class -->

<p>relational database 如何做join
透過主鍵連結兩張表,map做的事就是找到對應的key和value
key就設為主鍵,但value必須要有紀錄資料和資料來自哪張table
在reduce時才不會出錯</p>

<p>MapReduce Algorithm Design
提供紀錄中間狀態,提供需要for loop的程式執行
可以自己設定key</p>

<!-- class -->

<!-- class -->
<p>介紹dijkstra
那要怎麼把dijkstra做成mapreduce版本
dijkstra每一回合都要找到最小cost當成下一點
繼續遞迴的以cost最小的展開下去</p>

<p>mapreduce可以找到local的最小值
但不能找到global的最小值
mapreduce沒有提供share memory的機制去交換global的資料</p>

<p>先考慮unweight shortest path
每個edge都看成是1
那目標就變成找到最少的edge數</p>

<p>那就可以利用BFS解決這個問題</p>

<p>要將dijksta的問題改成mapreduce版本就要利用這個概念</p>

<p>平行shortest path algorithm</p>
<ul>
  <li>brute force approach</li>
  <li>all edge have unit distance</li>
  <li>Parallel BFS
    <ul>
      <li>iterative algorithm</li>
      <li>每次的結果存到disk,下次再讀取,但會有disk IO 問題</li>
    </ul>
  </li>
</ul>

<p>通常在mapreduce中的資料結構是以linklist的形式儲存
如果是sparse的矩陣會儲存太多的0,在map時會紀錄太多0
所以利用linklist來儲存,有值才紀錄
且對sort and shuffle的步驟負擔會比較小</p>

<p>每一的mapreduce會做一個hop(層),
且每回合的結果要寫回disk供下一回合使用</p>

<p>Inverted Files
利用linklist紀錄每個term出現在哪些文章中
<!-- class --></p>

<!-- 20170602 -->
<h1 id="9_2">Pig Programming</h1>

<ul>
  <li>sql-like language, 透過hadoop處理大量半結構化資料</li>
  <li>hadoop sub-project</li>
  <li>data flow language</li>
  <li>higher-level language</li>
</ul>

<p>收到user query後，pig會將query轉換成logical plan並在過程中做最佳化,logical plan之後產生physical plan(存取記憶體等操作),physical plan最後轉換成map reduce plan</p>

<p><strong>lazy execution</strong></p>

<blockquote>
  <p>直到執行request output(store/dump)才開始執行程式</p>
</blockquote>

<p>好處</p>
<ul>
  <li>in memory pipelining  <br />
  將執行完的結果直接傳給下個指令使用,不需要存到disk再去讀取</li>
  <li>filter re-ordering across multiple commands  <br />
  可能先做filter再開始處理join等等的指令,可以減少計算的複雜度(指令的最佳化)</li>
</ul>

<p><strong>data type</strong></p>
<ul>
  <li>int</li>
  <li>long</li>
  <li>float</li>
  <li>double</li>
  <li>chararray</li>
  <li>bytearray</li>
</ul>

<p><strong>指令</strong></p>
<ul>
  <li>load                                                <br />
  load ‘user.txt’;</li>
  <li>store
  store result into ‘output’</li>
  <li>dump</li>
  <li>filter<br />
  filter User by age &gt; 18 and age &lt;= 25</li>
  <li>join
    <ul>
      <li>outer join (right / left)<br />
  filter後濾掉的資料也會出現,以right或left為主</li>
    </ul>
  </li>
  <li>group<br />
  group user_url by url    <br />
  將欄位一樣的合併在一起<br />
  pig允許complex data type(一個欄位有多筆資料) <br />
  在relational database不允許有一個欄位有多個值的情況</li>
  <li>cogroup<br />
  cogroup Users by userId, Urls by user;<br />
  可以針對多個資料表做group</li>
  <li>foreach<br />
  foreach urlgroup generate group as url,<br />
  count(user_url) as count,</li>
  <li>order<br />
  ASC,DESC</li>
  <li>flatten</li>
  <li>distinct<br />
  將重複的濾掉</li>
</ul>

<p><strong>eval function(aggregation function)</strong></p>
<ul>
  <li>count</li>
  <li>sum</li>
  <li>avg</li>
  <li>min/max</li>
  <li>size</li>
  <li>concat</li>
  <li>tokenize</li>
  <li>diff</li>
</ul>

<p>example<br />
Word Count using Pig</p>
<ul>
  <li>Load file</li>
  <li>generate token 做斷詞</li>
  <li>group each word</li>
  <li>count word</li>
  <li>save file</li>
</ul>

<!-- 20170602 -->

<!----------------------------------- class --------------------------------------------->
<h4 id="agent-based-model">Agent-based Model</h4>

<p>代理人做事的程式
例如高鐵程式搶票.搜尋引擎</p>

<h4 id="agent">Agent</h4>
<ul>
  <li>獨立單位沒有辦法分割</li>
  <li>自動做事情</li>
  <li>自我決定事情</li>
  <li>在不同時間上有不同的狀態</li>
</ul>

<h4 id="agent-base如何模擬疫情擴散">agent base如何模擬疫情擴散</h4>
<p>FluTE
national-level simulation model
人口資料/通勤資料/旅行資料</p>

<p>population structure</p>
<ul>
  <li>discete-time stochastic simulation</li>
  <li>five age groups 0-4,5-18,19-29,30-64,64+ years</li>
  <li>家庭人口數</li>
  <li>每個人屬於什麼group,每個人有多個身份</li>
</ul>

<h4 id="social-network隱私問題">social network隱私問題</h4>

<ul>
  <li>identity disclosure 去識別化
  e.g. 將姓名,身份證號碼去掉</li>
</ul>

<p>去識別化後還是會有問題
如果去識別化後的點只有一個點degree是100
我剛好又知道A的朋友也是100個,那我可能會猜這個點是A</p>

<p>Privacy model
k-degree anonymity
    概念是造幾個假的資料，讓相同degree的點被猜出的機率下降
    在降低被猜出的機率同時要注意不要修改到太多原始資料
    將相同degree點的個數至少有k個</p>

<p>Problem define
    在點數相同的情形下,只修改邊,使相同degree的點個數至少有k個
    且前後graph的差異最小</p>

<p>GraphAnonymization algorithm
    Degree-sequence anonymization
        將每個點的degree由大排到小
<!----------------------------------- class ---------------------------------------------></p>

<!----------------------------------- class --------------------------------------------->
<h1 id="networks-with-signed-edges">Networks with Signed Edges</h1>

<!----------------------------------- class --------------------------------------------->

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2018/%E5%90%83%E4%BA%86%E9%82%A3%E9%9A%BB%E9%9D%92%E8%9B%99/">
            吃了那隻青蛙
            <small>25 Feb 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2018/readinglist/">
            讀書清單
            <small>25 Feb 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2017/dataStructure/">
            Data Structure
            <small>27 Mar 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>

  <hr>
  <!-- DISQUS comments -->
  
<div id="disqus_thread"></div>
<script>

var disqus_shortname = 'Note'; // required: replace example with your forum shortname
var disqus_identifier = '/2017/cloudComputing/';
var disqus_url = 'https://moved0311.github.com/2017/cloudComputing/';

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://https-moved0311-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</div>


    </div>
    
  </body>
</html>

