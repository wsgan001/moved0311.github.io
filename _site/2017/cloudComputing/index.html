<!DOCTYPE html>
<html lang="en-us">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      SocialCloudComputing &middot; Note
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/css/custom.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  
  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0b">
    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=228652297542969";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Note
        </a>
      </h1>
      <p class="lead"></p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/Archive/">Archives</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
      
        
          
        
      
			
	
	<li>
		<a href="https://github.com/moved0311">
		   <span class="fa-stack fa-lg">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-github fa-stack-1x icon"></i>
          </span>
		</a>
	</li>
	

	
	  <li>
		<a href="https://www.facebook.com/100000329876068">
		  <span class="fa-stack fa-lg">
              <i class="fa fa-circle fa-stack-2x"></i>
              <i class="fa fa-facebook fa-stack-1x icon"></i>
          </span>
		</a>
	  </li>
	

    </nav>

    <p>@ 2017</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">SocialCloudComputing</h1>
  <span class="post-date">25 Feb 2017</span>
  <h4 id="課程簡介">課程簡介</h4>
<ul>
  <li>Centrality Analysis</li>
  <li>Community Detection</li>
  <li>Link Prediction</li>
  <li>Label Prediction</li>
  <li>Influence maximization</li>
  <li>Outbreak Detection<br />
消息擴散路徑</li>
  <li>Role/Postion Analysis</li>
  <li>Social Relation Extraction</li>
  <li>Cloud Computing</li>
</ul>

<!--more-->

<h4 id="journals">Journals</h4>
<ul>
  <li>Nature</li>
  <li>Science</li>
  <li>Physical Review</li>
  <li>Social Networks</li>
  <li>ACM Transactions on Knowledge Discovery from Data (TKDD)</li>
  <li>ACM Transactions on Intelligent Systems and Technology(TIST)</li>
  <li>ACM Transactions on Social Computing(TSC)</li>
  <li>IEEE Transactions on Knowledge and Data Engineering(TKDE)</li>
  <li>IEEE Transactions on Computational Social System</li>
</ul>

<h4 id="social-networks">Social Networks</h4>

<table>
  <tbody>
    <tr>
      <td>Sociocentric</td>
      <td>Egocentric</td>
    </tr>
    <tr>
      <td>根據整群分析</td>
      <td>根據個人分析,向外延伸</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>information Network<br />
paper reference<br />
web hyperlink<br />
Language</li>
  <li>Social Network<br />
FB好友關係</li>
  <li>Technology Network<br />
電力系統(Power grid)</li>
  <li>Biologycal Network<br />
蛋白質互動關係,食物鏈</li>
</ul>

<p>為什麼要分這麼多類Network?</p>
<blockquote>
  <p>因為要分析的點不同,可能在information Network中很重要的,卻在Social Network可能不是那麼重要</p>
</blockquote>

<p><em>**</em> Network Properties</p>
<ol>
  <li>small-world effect
 六度分離理論<br />
 靠點和點距離關係分析</li>
  <li>Transitivity
 朋友的朋友很可能也是你朋友<br />
 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E8%81%9A%E7%B3%BB%E6%95%B0">Clustering Coeffieient</a></li>
  <li>Degree distribution
 Real world network: Power law		
 P<sub>k</sub> = CK<sup>-α</sup><br />
 Heavy-tailed degree distribution<br />
 大量很低的數量,集合起來還是很驚人</li>
  <li>Network resilience
 如果拿掉一些點/邊,連通性會有什麼變化？(e.g.有些人掛了,離職)<br />
 連接path的長度變長,或是disconnect <br />
 廣告投放要投在哪個點影響力最大,如果是傳染病隔離哪個點最有效?</li>
  <li>Mixing patterns<br />
 探討兩邊節點的type,可能因為什麼關係成為朋友(職業/興趣/文化)</li>
  <li>Degree Correlations
 觀察兩邊點的degree<br />
 內向和外向人(朋友多,degree高)觀察</li>
  <li>Community Structure 
 一群點邊的密度很高,稱作一個community  <br />
 clique 判斷是否認兩個點是否都有邊相連(clique problem 分團問題)<br />
 clique problem 是 NP-Complete<br />
 Connected commponets :有連通的子圖</li>
  <li>Network motifs    <br />
在音樂上motifs是一種作曲法,靈感的意思<br />
 在生物基因上是一些重複的pattern<br />
 在社群希望找到出現次數較高的motifs(最常出現的subgraph)</li>
</ol>

<p>CERN
<a href="https://zh.wikipedia.org/wiki/%E7%B1%B3%E7%88%BE%E6%A0%BC%E5%80%AB%E5%AF%A6%E9%A9%97">米爾格倫實驗 Milgram experiment</a>服從威權實驗 <br />
random graph</p>

<p><strong>Central of Network</strong></p>
<ul>
  <li>找到最重要的點(central)</li>
</ul>

<p>local</p>
<blockquote>
  <ol>
    <li>Degree</li>
  </ol>
</blockquote>

<p>global</p>
<blockquote>
  <ol>
    <li>Closeness</li>
    <li>Betweeness</li>
    <li>Eigenvector</li>
  </ol>
</blockquote>

<ul>
  <li>Group Centrality 一群最有影響力的人<br />
在小世界理論中,如果送信到目標的前一步,都是經由特定的3個人,代表這三個人很重要,<br />
目前social network還無法透過社群網站判斷這些人</li>
</ul>

<p><strong>Social actors(群眾的智慧)</strong></p>
<ol>
  <li>Connectors<br />
認識很多人,很擅長社交</li>
  <li>Mavens<br />
資訊專家,知道很多各式訊息</li>
  <li>Salesman<br />
容易說服別人,擅長協調</li>
</ol>

<p>判斷social network的四種centrality</p>
<ol>
  <li>Degree centrality(local)<br />
點的重要性,若network的規模大小不同,做normalize(除總size-1)</li>
  <li>Betweeness Centrality<br />
Node<sub>i</sub> A到B的shortest path有幾條經過i</li>
  <li>Closeness Centrality
點i和所有點j的shortest path平均的距離</li>
  <li>Eigenvector Centrality  <br />
這個點的重要性,看他朋友點的重要性<br />
eigenvector
    <blockquote>
      <p>一個向量乘上一個矩陣(transform),方向不變但scale可能會變<br />
Ax = <script type="math/tex">\lambda</script>x<br />
A矩陣代表social network關係(1:朋友關係,0:不是朋友)<br />
x代表重要性<br />
概念類似PageRank,page rank的值是連到他網頁的值加總</p>
    </blockquote>
  </li>
</ol>

<p>HIT <br />
Hub<br />
推薦的authoritative有多高<br />
Authoritative page<br />
有多少hub推薦</p>

<p><strong>最短路徑演算法</strong><br />
unweighted graph</p>
<ol>
  <li>BFS</li>
  <li>Floyd-Warshall</li>
</ol>

<p><strong>Group centrality</strong><br />
找出social network中幾個最有影響力的人<br />
或指定某幾個人想觀察這幾人的影響力</p>

<p>group centrality一群人一起看,影響幾個人(有連線)<br />
不能將每個單一人的degree加總,會有重複的</p>

<p>Social Group Analysis
community detection algorithm</p>

<!-- 20170413 start -->
<p><strong>Properties of cohesion 凝聚力的判斷</strong></p>
<ol>
  <li>Mutuality of ties<br />
 所有subgroup彼此都有編相連,在graph中就是完全圖的概念<br />
 e.g. clique</li>
  <li>Closeness or reachability of subgroup members<br />
 不需要直接有邊相連,間接有相連就行了<br />
 e.g. N-clique,N-clan,N-club</li>
  <li>Frquency of ties among members<br />
 Mutuality of ties是說假設有n個人必須要和n-1個人相連,<br />
 那Frquency of ties among members只需要和n-k個人相連就可以了<br />
 是Mutuality of ties放寬版本<br />
 e.g. K-plex,K-core</li>
  <li>Relative frequency of ties among subgroup members compared to non-member</li>
</ol>

<p><strong>Clique</strong></p>
<blockquote>
  <p>maximal complete subgraph,最大的子圖任兩點都有邊相連</p>
</blockquote>
<hr />

<p><img src="/img/cloudcomputing/community01.png" alt="clique img" /></p>

<ul>
  <li>N-clique <br />
  在grahp中,任兩個點之間的距離&lt;N  <br />
  e.g. 2-cliques: {1,2,3,4,5},{2,3,4,5,6}</li>
  <li>N-clan<br />
  必須是N-clique<br />
  在subgraph中,任兩個點之間的距離&lt;N<br />
  e.g. 2-clan: {2,3,4,5,6} <br />
  (4-&gt;5要經過6,但只考慮1,2,3,4,5這個subgraph)</li>
  <li>N-club<br />
  不必是N-clique,但一定要是subgraph of n-cliques  <br />
  2-clubs: {1,2,3,4},{1,2,3,5},{2,3,4,5,6}</li>
  <li>K-plex<br />
  如果是clique每個點的degree是n-1<br />
  如果是k-plex,每個點的degree是n-k<br />
  假設subgraph有4個點,2-plex每個點的degree至少是2</li>
  <li>K-core<br />
  至少和k個人是朋友
  每個點的degree至少是k</li>
</ul>

<p><strong>Community Detection Approaches</strong></p>
<ol>
  <li>Kernighan-Lin Alog(KL algorithm)</li>
  <li>Hierarchical Clustering</li>
  <li>Modularity Maximization</li>
  <li>Bridge-Cut Algo</li>
</ol>

<h3 id="kl-algorithm">KL algorithm</h3>
<blockquote>
  <p>input: weighted graph<br />
output: 切成兩個equal-size subgraph,且橫跨兩群的crossing edge <br />
目的是相望群和群之間差異大,群內部的差異小</p>
</blockquote>

<p><strong>步驟</strong></p>
<ol>
  <li>任意切成兩半</li>
  <li>計算每一點的difference</li>
  <li>計算每個邊的gain</li>
  <li>從gain最大的開始做交換,交換後的點不再考慮(lock)</li>
  <li>交換到直到全部的點都被lock住</li>
  <li>挑gain總和最大的就是最終交換結果</li>
</ol>

<p>交換數回合,若遇到gain是負的紀錄下來並繼續嘗試做交換,到最後再找gain最好的
交換完後的點就lock住不進入下一回合</p>

<ul>
  <li>external cost<br />
  crossing edge的cost(連向別群的cost)(cut-size)</li>
  <li>internal cost<br />
  連向同群的cost</li>
  <li>difference<br />
  external cost - internal cost</li>
</ul>

<p><strong>Gain</strong></p>
<blockquote>
  <p>用來評估是否要交換的值
例如a,b屬於不同群,ab做交換<br />
Gain = <script type="math/tex">D_a + D_b - 2\times W_{ab}</script><br />
(Difference a + Difference b - 2*weighted ab)</p>
</blockquote>

<p>若考慮a,b交換<br />
old cost = <script type="math/tex">z + E_a + E_b - W_{ab}</script> <br />
new cost = <script type="math/tex">z + I_a + I_b + W_{ab}</script></p>

<blockquote>
  <p>z (與a,b沒有連接的其他crossing edge總和)<br />
E (external cost)<br />
I (internal cost)</p>
</blockquote>

<p><strong>KL algorithm複雜度</strong><br />
<script type="math/tex">O(n^2)</script> 找到最適合交換的兩點,有n pair要交換<br />
⇒ <script type="math/tex">O(n^3)</script></p>

<!-- 20170413 end -->

<p>hiraichiecal 
bottom-up<br />
每一回合都找兩個最像的做合併<br />
single link<br />
    距離取min
complete link
    距離取max</p>

<p>分群    <br />
community 同群邊的值要越大越好</p>

<p>Distance Matrix</p>
<ol>
  <li>Approach1  <br />
計算weights Wij
    <ul>
      <li>i到j的路徑越多代表i和j關係越好</li>
    </ul>
    <ul>
      <li>只能找non-overlapped paths</li>
      <li>只要i到j的路徑都算(weighted by length)
 Xij = 1/Wij</li>
    </ul>

    <p>Reduction
     由A問題轉換到B問題</p>
  </li>
  <li>Approach 2
 如果i和j視同一群,那他們有相似的behavior
 behavoir
     i和j到commuinty其他點的平均距離相似</li>
  <li>Approach 3
 J(i,j)/min(Ki,Kj)<br />
 看兩個人共同朋友個數,共同朋友越多J(i,j)越大</li>
</ol>

<p>Edge-removal Approach<br />
不斷的拿掉邊,會出現越多的群數,直到符合要的群數<br />
拿掉bridge edge,</p>
<ol>
  <li>betweeness
一開始想說可以用degree少,但不夠完全<br />
 在centrality的betweeness是以node考量<br />
 在這的betweeness是以edge考量</li>
</ol>

<p>GN algorithm<br />
拿掉betweeness最高的邊 -&gt; 重算betweeness -&gt; 計算community
top-down(起始是一個commuinity,並分群下去)
計算邊的betweeness</p>
<ol>
  <li>shortest path<br />
 任兩點最短路徑有多少條會經過邊</li>
  <li>Random-walk 
 計算a會走到b的機率<br />
 a走到b會經過邊v的機率</li>
  <li>Current-flow
 引進電路學概念的計算方法</li>
</ol>

<p>缺點</p>
<ol>
  <li>計算最短路徑耗時
 O(m^2n)<br />
 m edge (O(mn)betweeness)</li>
  <li>什麼時候停?</li>
</ol>

<p>改善</p>
<ol>
  <li>Partial betweeness (Apprximation)<br />
Randomly sampled by Monte Carlo Estimate</li>
  <li>Edge clustering coefficient
  coefficient越高代表關係越好
the smaller coefficient the higher betweeness</li>
</ol>

<p>Modularity
    Modularity measure:
        how good a particular partition forms a community.
        評估community切分的好不好</p>

<p>U 看internal edge的比例<br />
R 平均i和j會有邊的機率(期望值)      <br />
Q = U - R</p>

<p>Q = 0 no community<br />
Q ~ 1 prefect cut</p>

<p><strong>Newman Fast Alogorithm</strong><br />
利用hireachcal合併,並每個步驟算modurity,並找出最高的Q做切分<br />
<strong>Bridge cut</strong><br />
integrity一致性<br />
N(v)
d(v): degree of node
Density
Direct neighbor subgraph of v<br />
Clustering coeffiecient <br />
	觀察v的鄰居的朋友關係<br />
	例如v有4個朋友,那4個人最多有6個關係,算關係的比例<br />
	實際上有關係/最多有幾個關係<br />
Bridge Centrality<br />
	<strong>rank</strong> of betweenness centrality * <strong>rank</strong> of bridging coeffiecient<br />
	如果只考慮betweeness(global)會有一些情況不太好  <br />
	加入bridge centrality可以考慮到local的特質</p>

<p><strong>Community Search</strong><br />
給一個social network,並給一些query(其中幾個人),<br />
given grahp G, a set of query node<br />
goal: find a densely subgraph of G, and contains the query nodes</p>

<p><strong>Induced Subgraph</strong><br />
xy edge在G中,xy edge也要在induce subgraph中</p>

<p>goodness function</p>
<ol>
  <li>edge degree
時間複雜度太大</li>
  <li>average degree</li>
  <li>minumin degree
這群人認識最少的人,讓這個人的值變大
induced subgraph的degree<br />
容易受到outlier影響</li>
</ol>

<p>Constrain<br />
distance constrain<br />
限制邀請來的人的最長距離</p>

<p><strong>Monotone Function</strong></p>
<ul>
  <li>monotone increaing</li>
  <li>monotone decresing</li>
  <li>non-monotone</li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2017/dataStructure/">
            Data Structure
            <small>27 Mar 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2017/python/">
            python
            <small>08 Mar 2017</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2017/webSearching/">
            WebSearching
            <small>07 Mar 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>

  
    <div class="fb-comments" data-href="http://localhost:4000/2017/cloudComputing/" data-width="auto" data-numposts="5"></div>

  
</div>

    </div>

  </body>
</html>
